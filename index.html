<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Clone</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #3a3a3a;
            background-image: linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));
        }
        #instructions {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            text-shadow: 2px 2px #222;
        }
        #title {
            font-size: 64px;
            margin-bottom: 20px;
        }
        #play-button {
            font-size: 24px;
            padding: 10px 20px;
            cursor: pointer;
            background-color: #707070;
            border: 2px solid;
            border-color: #c6c6c6 #555555 #555555 #c6c6c6;
            box-shadow: inset 0 0 0 2px #000000;
            margin-bottom: 20px;
        }
        #play-button:hover {
            background-color: #7f7f7f;
        }
        #controls-info {
            font-size: 16px;
            line-height: 1.5;
        }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 1px solid white; transform: translate(-50%, -50%); mix-blend-mode: difference; pointer-events: none;}
        #settings {
            margin-top: 30px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 5px;
            border: 2px solid #222;
        }
        #settings div { margin-bottom: 10px; text-align: left; font-size: 16px;}
        #inventory { position: absolute; left: 50%; bottom: 40px; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 8px; z-index: 10; border: 2px solid #222;}
        .inv-slot { width: 40px; height: 40px; border: 2px solid #fff; border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(255,255,255,0.1); transition: border 0.2s;}
        .inv-slot.selected { border: 2px solid #ff0; background: rgba(255,255,0,0.2);}
        .inv-block { width: 28px; height: 28px; border-radius: 2px; border: 1px solid #222; background-size: cover; }
        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px #222;
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
        }
        </style>
    </head>
    <body>
        <div id="fps-counter"></div>
        <div id="blocker">
        <div id="instructions">
            <div id="title">Minecraft Clone</div>
            <div id="play-button">Click to play</div>
            <p id="controls-info">
                WASD = Move<br/>
                SPACE = Jump / Fly Up<br/>
                SHIFT = Fly Down<br/>
                F = Toggle Fly<br/>
                MOUSE = Look<br/>
                LEFT CLICK = Destroy Block<br/>
                RIGHT CLICK = Place Block<br/>
                1-9 or Mouse Wheel = Select Block
            </p>
            <div id="settings">
                <div>
                    <label for="sensitivity">Sensitivity</label>
                    <input type="range" id="sensitivity" min="0.1" max="3" value="1" step="0.1">
                </div>
                <div>
                    <input type="checkbox" id="invertY">
                    <label for="invertY">Invert Y-Axis</label>
                </div>
            </div>
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="inventory"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- MODIFIED POINTER LOCK CONTROLS (to support Invert Y) ---
        const _euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
        const _vector = new THREE.Vector3();
        const _changeEvent = { type: 'change' };
        const _lockEvent = { type: 'lock' };
        const _unlockEvent = { type: 'unlock' };
        const _PI_2 = Math.PI / 2;

        class PointerLockControls extends THREE.EventDispatcher {
            constructor( camera, domElement ) {
                super();
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.pointerSpeed = 1.0;
                this.invertY = false; // Custom property
                const scope = this;

                function onMouseMove( event ) {
                    if ( scope.isLocked === false ) return;
                    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                    _euler.setFromQuaternion( camera.quaternion );
                    _euler.y -= movementX * 0.002 * scope.pointerSpeed;
                    // --- MODIFICATION HERE ---
                    _euler.x -= movementY * 0.002 * scope.pointerSpeed * (scope.invertY ? -1 : 1);
                    // --- END MODIFICATION ---
                    _euler.x = Math.max( _PI_2 - scope.maxPolarAngle, Math.min( _PI_2 - scope.minPolarAngle, _euler.x ) );
                    camera.quaternion.setFromEuler( _euler );
                    scope.dispatchEvent( _changeEvent );
                }

                function onPointerlockChange() {
                    if ( scope.domElement.ownerDocument.pointerLockElement === scope.domElement ) {
                        scope.dispatchEvent( _lockEvent );
                        scope.isLocked = true;
                    } else {
                        scope.dispatchEvent( _unlockEvent );
                        scope.isLocked = false;
                    }
                }

                function onPointerlockError() {
                    console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );
                }

                this.connect = function () {
                    scope.domElement.ownerDocument.addEventListener( 'mousemove', onMouseMove );
                    scope.domElement.ownerDocument.addEventListener( 'pointerlockchange', onPointerlockChange );
                    scope.domElement.ownerDocument.addEventListener( 'pointerlockerror', onPointerlockError );
                };

                this.disconnect = function () {
                    scope.domElement.ownerDocument.removeEventListener( 'mousemove', onMouseMove );
                    scope.domElement.ownerDocument.removeEventListener( 'pointerlockchange', onPointerlockChange );
                    scope.domElement.ownerDocument.removeEventListener( 'pointerlockerror', onPointerlockError );
                };

                this.dispose = function () {
                    this.disconnect();
                };

                this.getObject = function () {
                    return camera;
                };

                this.getDirection = function () {
                    const direction = new THREE.Vector3( 0, 0, - 1 );
                    return function ( v ) {
                        return v.copy( direction ).applyQuaternion( camera.quaternion );
                    };
                }();

                this.moveForward = function ( distance ) {
                    _vector.setFromMatrixColumn( camera.matrix, 0 );
                    _vector.crossVectors( camera.up, _vector );
                    camera.position.addScaledVector( _vector, distance );
                };

                this.moveRight = function ( distance ) {
                    _vector.setFromMatrixColumn( camera.matrix, 0 );
                    camera.position.addScaledVector( _vector, distance );
                };

                this.lock = function () {
                    this.domElement.requestPointerLock();
                };

                this.unlock = function () {
                    scope.domElement.ownerDocument.exitPointerLock();
                };

                this.connect();
            }
        }
        // --- END OF POINTER LOCK CONTROLS ---

        // --- Block Types ---
        const BLOCK_TYPES = [
            { name: 'Grass', color: 0x559020 },
            { name: 'Stone', color: 0x808080 },
            { name: 'Dirt',  color: 0x9b7653 },
            { name: 'Sand',  color: 0xf0e68c },
            { name: 'Wood',  color: 0x8b5a2b }
        ];
        let selectedBlockIndex = 0;

        // --- Materials ---
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
        const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.BackSide });

        // --- Block Creation Helper ---
        function createBlock(typeIndex) {
            const blockData = BLOCK_TYPES[typeIndex];
            const group = new THREE.Group();
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: blockData.color });
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, lineMaterial);
            line.raycast = () => {}; // Disable raycasting for the block edges
            group.add(line);
            return group;
        }

        // --- Inventory UI ---
        function buildInventoryUI() {
            const inv = document.getElementById('inventory');
            inv.innerHTML = '';
            BLOCK_TYPES.forEach((block, i) => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot' + (i === selectedBlockIndex ? ' selected' : '');
                slot.title = block.name;
                slot.dataset.index = i;
                const blockDiv = document.createElement('div');
                blockDiv.className = 'inv-block';
                blockDiv.style.backgroundColor = '#' + new THREE.Color(block.color).getHexString();
                slot.appendChild(blockDiv);
                inv.appendChild(slot);
            });
        }

        // --- Collision Helpers ---
        function playerAABB() {
            const pos = controls.getObject().position;
            return {
                min: new THREE.Vector3(pos.x - 0.3, pos.y - 1.2, pos.z - 0.3),
                max: new THREE.Vector3(pos.x + 0.3, pos.y + 0.3, pos.z + 0.3)
            };
        }

        function boxAABB(meshGroup) {
            const pos = meshGroup.position;
            return {
                min: new THREE.Vector3(pos.x - 0.5, pos.y - 0.5, pos.z - 0.5),
                max: new THREE.Vector3(pos.x + 0.5, pos.y + 0.5, pos.z + 0.5)
            };
        }

        function aabbIntersect(a, b) {
            return (
                a.min.x <= b.max.x && a.max.x >= b.min.x &&
                a.min.y <= b.max.y && a.max.y >= b.min.y &&
                a.min.z <= b.max.z && a.max.z >= b.min.z
            );
        }

        function resolveCollisions() {
            const player = playerAABB();
            const pos = controls.getObject().position;
            for (let obj of objects) {
                if (obj.isFloor) continue;
                const box = boxAABB(obj);
                if (aabbIntersect(player, box)) {
                    const dx1 = box.max.x - player.min.x, dx2 = player.max.x - box.min.x;
                    const dy1 = box.max.y - player.min.y, dy2 = player.max.y - box.min.y;
                    const dz1 = box.max.z - player.min.z, dz2 = player.max.z - box.min.z;
                    const minX = dx1 < dx2 ? dx1 : -dx2;
                    const minY = dy1 < dy2 ? dy1 : -dy2;
                    const minZ = dz1 < dz2 ? dz1 : -dz2;
                    const absX = Math.abs(minX), absY = Math.abs(minY), absZ = Math.abs(minZ);
                    if (absX < absY && absX < absZ) {
                        pos.x += minX;
                        velocity.x = 0;
                    } else if (absY < absX && absY < absZ) {
                        pos.y += minY;
                        velocity.y = 0;
                    } else {
                        pos.z += minZ;
                        velocity.z = 0;
                    }
                }
            }
        }

        // --- Main ---
        let camera, scene, renderer, controls;
        const objects = [];
        let raycaster;
        let outlineMesh = null;
        let lastIntersected = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false, isFlying = false, moveUp = false, moveDown = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // FPS Counter
        let fpsCounter;
        let frameCount = 0;
        let lastFpsUpdateTime = 0;

        // --- Map/World Settings ---
        const worldSize = 30;
        const worldMinX = -worldSize;
        const worldMaxX = worldSize;
        const worldMinZ = -worldSize;
        const worldMaxZ = worldSize;
        const worldMinY = -10; // Respawn height
        const spawnPoint = new THREE.Vector3(0, 10, 0);

        // --- Settings Persistence ---
        function saveSettings() {
            localStorage.setItem('mcclone_sensitivity', String(controls.pointerSpeed));
            localStorage.setItem('mcclone_invertY', controls.invertY ? '1' : '0');
        }
        function loadSettings() {
            return {
                sensitivity: parseFloat(localStorage.getItem('mcclone_sensitivity')) || 1,
                invertY: localStorage.getItem('mcclone_invertY') === '1'
            };
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 75);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(spawnPoint);

            controls = new PointerLockControls(camera, document.body);
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            const playButton = document.getElementById('play-button');
            const sensitivitySlider = document.getElementById('sensitivity');
            const invertYCheckbox = document.getElementById('invertY');
            const inventoryDiv = document.getElementById('inventory');
            fpsCounter = document.getElementById('fps-counter');

            // --- Load settings from localStorage ---
            const settings = loadSettings();
            controls.pointerSpeed = settings.sensitivity;
            controls.invertY = settings.invertY;
            sensitivitySlider.value = String(settings.sensitivity);
            invertYCheckbox.checked = settings.invertY;

            playButton.addEventListener('click', () => controls.lock());
            sensitivitySlider.addEventListener('input', (e) => {
                controls.pointerSpeed = Number(e.target.value);
                saveSettings();
            });
            invertYCheckbox.addEventListener('change', (e) => {
                controls.invertY = e.target.checked;
                saveSettings();
            });

            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'block';
                instructions.style.display = '';
            });
            scene.add(controls.getObject());

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onMouseWheel, { passive: false });
            inventoryDiv.addEventListener('click', onInventoryClick);
            document.addEventListener('mouseup', onMouseUp); // Changed from mousedown
            document.addEventListener('contextmenu', e => e.preventDefault());

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(-1, 1.75, 1).multiplyScalar(30);
            scene.add(dirLight);

            // --- Generate a flat world ---
            for (let x = worldMinX; x <= worldMaxX; x++) {
                for (let z = worldMinZ; z <= worldMaxZ; z++) {
                    const grass = createBlock(0); // Grass block
                    grass.position.set(x, 0.5, z);
                    grass.isFloor = true;
                    scene.add(grass);
                    objects.push(grass);
                }
            }

            window.addEventListener('resize', onWindowResize);
            buildInventoryUI();
        }

        function onKeyDown(event) {
            if (event.repeat) return;
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyF': isFlying = !isFlying; velocity.y = 0; break;
                case 'Space':
                    if (isFlying) moveUp = true;
                    else if (canJump) { velocity.y += 35; canJump = false; }
                    break;
                case 'ShiftLeft': if(isFlying) moveDown = true; break;
                case 'Digit1': selectHotbar(0); break;
                case 'Digit2': selectHotbar(1); break;
                case 'Digit3': selectHotbar(2); break;
                case 'Digit4': selectHotbar(3); break;
                case 'Digit5': selectHotbar(4); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': moveDown = false; break;
            }
        }

        function onMouseWheel(e) {
            if (!controls.isLocked) return;
            e.preventDefault();
            const scroll = e.deltaY > 0 ? 1 : -1;
            selectHotbar((selectedBlockIndex + scroll + BLOCK_TYPES.length) % BLOCK_TYPES.length);
        }

        function onInventoryClick(e) {
            const slot = e.target.closest('.inv-slot');
            if (slot) selectHotbar(Number(slot.dataset.index));
        }

        function selectHotbar(idx) {
            if (idx < 0 || idx >= BLOCK_TYPES.length) return;
            selectedBlockIndex = idx;
            buildInventoryUI();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseUp(event) { // Renamed from onMouseDown
            if (!controls.isLocked) return;

            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            raycaster.far = 5;
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const intersectedGroup = intersect.object.parent;

                if (event.button === 2) { // Right click to place
                    const newBlock = createBlock(selectedBlockIndex);
                    newBlock.position.copy(intersectedGroup.position).add(intersect.face.normal);
                    // Prevent placing inside player and outside world bounds
                    if (
                        !aabbIntersect(playerAABB(), boxAABB(newBlock)) &&
                        newBlock.position.x >= worldMinX && newBlock.position.x <= worldMaxX &&
                        newBlock.position.z >= worldMinZ && newBlock.position.z <= worldMaxZ &&
                        newBlock.position.y >= worldMinY
                    ) {
                        scene.add(newBlock);
                        objects.push(newBlock);
                    }
                } else if (event.button === 0) { // Left click to destroy
                    if (intersectedGroup.isFloor !== true) {
                        scene.remove(intersectedGroup);
                        objects.splice(objects.indexOf(intersectedGroup), 1);
                    }
                }
            }
        }

        function updateOutline() {
            if (!controls.isLocked) {
                if (outlineMesh) {
                    scene.remove(outlineMesh);
                    outlineMesh = null;
                    lastIntersected = null;
                }
                return;
            }

            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            raycaster.far = 5;
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                const intersectedGroup = intersects[0].object.parent;
                if (lastIntersected !== intersectedGroup) {
                    if (outlineMesh) scene.remove(outlineMesh);
                    lastIntersected = intersectedGroup;
                    const blockGeometry = intersectedGroup.children[0].geometry;
                    outlineMesh = new THREE.Mesh(blockGeometry, outlineMaterial);
                    outlineMesh.position.copy(intersectedGroup.position);
                    outlineMesh.scale.set(1.05, 1.05, 1.05);
                    scene.add(outlineMesh);
                }
            } else {
                if (outlineMesh) {
                    scene.remove(outlineMesh);
                    outlineMesh = null;
                }
                lastIntersected = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();

            // FPS Counter
            frameCount++;
            if (time >= lastFpsUpdateTime + 1000) {
                fpsCounter.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastFpsUpdateTime = time;
            }

            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (isFlying) {
                    const flySpeed = 40.0; // Slower speed for flying
                    velocity.y -= velocity.y * 10.0 * delta; // Vertical damping

                    if (moveForward || moveBackward) velocity.z -= direction.z * flySpeed * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * flySpeed * delta;
                    if (moveUp) velocity.y += flySpeed * delta;
                    if (moveDown) velocity.y -= flySpeed * delta;
                    canJump = false;
                } else {
                    raycaster.ray.origin.copy(controls.getObject().position);
                    raycaster.ray.origin.y -= 1.2;
                    raycaster.far = 0.2;
                    const onObject = raycaster.intersectObjects(objects, true).length > 0;

                    velocity.y -= 9.8 * 30.0 * delta; // Gravity

                    if (moveForward || moveBackward) velocity.z -= direction.z * 80.0 * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * 80.0 * delta;

                    if (onObject) {
                        velocity.y = Math.max(0, velocity.y);
                        canJump = true;
                    }
                }

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                resolveCollisions();

                // --- Respawn if out of bounds or too deep ---
                const pos = controls.getObject().position;
                if (
                    pos.x < worldMinX - 2 || pos.x > worldMaxX + 2 ||
                    pos.z < worldMinZ - 2 || pos.z > worldMaxZ + 2 ||
                    pos.y < worldMinY - 2
                ) {
                    // Respawn at spawnPoint
                    pos.copy(spawnPoint);
                    velocity.set(0, 0, 0);
                }

                if (!isFlying && controls.getObject().position.y < 2.2) {
                    velocity.y = 0;
                    controls.getObject().position.y = 2.2;
                    canJump = true;
                }
                updateOutline();
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
